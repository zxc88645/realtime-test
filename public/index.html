<!doctype html>
<html lang="zh-Hant">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GPT 即時延遲實驗室</title>
    <script src="https://cdn.tailwindcss.com?plugins=forms,typography"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ['"Noto Sans TC"', '"Segoe UI"', 'system-ui', 'sans-serif'],
            },
          },
        },
      };
    </script>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div id="app" class="app-shell">
      <header class="app-header">
        <div class="app-header__inner">
          <div class="app-header__content">
            <div class="app-title-group">
              <span class="eyebrow">Realtime Playground</span>
              <h1 class="page-title">GPT 即時延遲實驗室</h1>
              <p class="body-muted">
                建議先挑選傳輸模式與回覆語言，再按下「連線」。成功建立連線後即可在同一個聊天面板中比較
                WebSocket 與 WebRTC 的往返延遲表現。
              </p>
            </div>
            <div class="header-actions">
              <button
                type="button"
                class="ghost-button"
                @click="toggleTheme"
                :aria-pressed="isDarkTheme"
              >
                <span aria-hidden="true">{{ isDarkTheme ? '🌙' : '🌞' }}</span>
                <span>{{ themeToggleLabel }}</span>
              </button>
            </div>
          </div>
          <div class="callout">
            範例伺服器必須在環境變數中設定
            <code>OPENAI_API_KEY</code>
            才能代理請求；若缺少金鑰，所選模式會立即回報錯誤並停止連線。
          </div>
        </div>
      </header>

      <div class="app-layout">
        <aside class="app-sidebar">
          <section class="sidebar-section">
            <h2 class="section-heading">選擇傳輸模式</h2>
            <p class="section-subtle">切換後會自動結束目前的連線並清除統計資料。</p>
            <fieldset>
              <legend class="visually-hidden">可用的連線模式</legend>
              <div class="mode-list">
                <label v-for="option in modeOptions" :key="option.id" class="mode-option">
                  <input
                    type="radio"
                    name="mode"
                    :value="option.id"
                    v-model="selectedMode"
                  />
                  <span class="mode-option__label">
                    <span class="mode-option__title">{{ option.label }}</span>
                    <span class="mode-option__description">{{ option.description }}</span>
                  </span>
                </label>
              </div>
            </fieldset>
            <p class="note-card">切換模式後記得重新按下「連線」。</p>
          </section>

          <section class="sidebar-section">
            <h2 class="section-heading">回覆語言</h2>
            <p class="section-subtle">套用於下一則訊息，可立即與 GPT 練習多國語言。</p>
            <label class="select-wrapper">
              <span class="sr-only">選擇回覆語言</span>
              <select v-model="selectedLanguageId">
                <option
                  v-for="option in languageOptions"
                  :key="option.id"
                  :value="option.id"
                >
                  {{ option.label }}
                </option>
              </select>
            </label>
            <p class="language-hint">{{ activeLanguage.description }}</p>
          </section>

          <section class="sidebar-section">
            <h2 class="section-heading">連線控制</h2>
            <button
              id="start"
              type="button"
              class="primary-button"
              @click="onStartClick"
              :disabled="startDisabled"
            >
              {{ startLabel }}
            </button>
            <p class="section-subtle">
              {{ activeModeLabel }}
              會保持唯一通道；重新連線時會清除尚未完成的延遲樣本並重新建立管道。
            </p>
            <p class="warning-text">
              WebSocket 模式目前僅支援文字互動，如需即時語音請改用 WebRTC。
            </p>
          </section>

          <section class="sidebar-section">
            <h2 class="section-heading">操作提示</h2>
            <ul class="tip-list">
              <li class="tip-item">
                <span class="tip-marker" aria-hidden="true"></span>
                <span
                  >WebRTC
                  需要麥克風權限才能傳輸即時語音；若拒絕權限，系統會自動改為僅接收。</span
                >
              </li>
              <li class="tip-item">
                <span class="tip-marker" aria-hidden="true"></span>
                <span
                  >傳送訊息後可觀察最新延遲、平均延遲與樣本數，協助比較不同傳輸模式。</span
                >
              </li>
              <li class="tip-item">
                <span class="tip-marker" aria-hidden="true"></span>
                <span>錯誤訊息會直接出現在聊天面板中，方便排除故障。</span>
              </li>
            </ul>
          </section>
        </aside>

        <main class="main-column">
          <section class="stat-surface">
            <div class="grid gap-4 md:grid-cols-2 xl:grid-cols-4">
              <article class="stat-card">
                <h3>狀態</h3>
                <p class="stat-value">{{ activeTransport.status }}</p>
              </article>
              <article class="stat-card">
                <h3>最新延遲</h3>
                <p class="stat-value">{{ activeTransport.latest }}</p>
              </article>
              <article class="stat-card">
                <h3>平均延遲</h3>
                <p class="stat-value">{{ activeTransport.average }}</p>
              </article>
              <article class="stat-card">
                <h3>樣本數</h3>
                <p class="stat-value">{{ activeTransport.samples }}</p>
              </article>
            </div>
          </section>

          <section class="main-panel">
            <div class="main-panel__header">
              <h2 class="section-title">{{ activeModeLabel }} 聊天面板</h2>
              <p class="body-muted">{{ activeModeDescription }}</p>
            </div>
            <div class="main-panel__messages">
              <div class="chat-scroll" aria-live="polite">
                <template v-if="activeTransport.messages.length">
                  <div
                    v-for="item in activeTransport.messages"
                    :key="item.id"
                    :class="messageContainerClass(item.role)"
                  >
                    <span class="message-role-label">{{ roleLabel(item.role) }}</span>
                    <div :class="messageBubbleClass(item.role)">
                      <p class="leading-relaxed">{{ item.text || '（等待回覆…）' }}</p>
                    </div>
                  </div>
                </template>
                <p v-else class="empty-state">
                  尚未傳送任何訊息。請先建立連線並輸入訊息開始對話。
                </p>
              </div>
            </div>
            <form
              id="message-form"
              class="main-panel__form"
              @submit.prevent="sendMessage"
            >
              <label for="message" class="sr-only">
                {{ activeModeLabel }} 準備就緒後，傳訊給 GPT
              </label>
              <div class="form-actions">
                <input
                  id="message"
                  ref="messageInputRef"
                  name="message"
                  type="text"
                  placeholder="問 GPT 一個問題…"
                  autocomplete="off"
                  required
                  v-model="message"
                  :disabled="!canSend"
                  class="input-field"
                />
                <button
                  id="send"
                  type="submit"
                  :disabled="!canSend"
                  class="primary-button"
                >
                  送出
                </button>
              </div>
              <p class="helper-text">
                訊息只會送往當前選定的模式，並會記錄自送出至回覆完成的往返延遲。
              </p>
            </form>
          </section>

          <section class="info-panel">
            <h2>運作流程</h2>
            <ol>
              <li>
                伺服器會將 WebSocket 連線代理至 OpenAI 的
                <code>/v1/realtime</code>
                端點，並能簽發瀏覽器使用的 WebRTC 短效金鑰。
              </li>
              <li>
                當你送出訊息時，所選模式會發送
                <code>response.create</code>
                事件，讓 GPT 收到你的提示並開始串流回覆。
              </li>
              <li>
                頁面會記錄每次請求的時間點，直到 GPT
                宣告回覆完成為止，並即時更新延遲儀表板。
              </li>
            </ol>
          </section>
        </main>
      </div>
    </div>
    <script src="app.js" type="module"></script>
  </body>
</html>
